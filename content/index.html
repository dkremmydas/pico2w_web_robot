<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="US-ASCII">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robot Control</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        .control-table {
            margin: 20px auto;
            border-spacing: 10px;
        }

        .control-table td {
            text-align: center;
        }

        .control-button {
            width: 100px;
            height: 50px;
            font-size: 16px;
        }

        .ip-input {
            display: block;
            margin: 20px auto;
            padding: 10px;
            font-size: 16px;
            width: 300px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">Robot Control Panel</h1>

    <table class="control-table">
        <tr>
            <td><button class="control-button" data-command="FLT">Front Left</button></td>
            <td><button class="control-button" data-command="FWD">Go Front</button></td>
            <td><button class="control-button" data-command="FRT">Front Right</button></td>
            <td></td>
        </tr>
        <tr>
            <td><button class="control-button" data-command="LFT">Left</button></td>
            <td><button class="control-button" data-command="STP">STOP NOW</button></td>
            <td><button class="control-button" data-command="RGT">Right</button></td>
        </tr>
        <tr>
            <td><button class="control-button" data-command="BLT">Back Left</button></td>
            <td><button class="control-button" data-command="BWD">Go Back</button></td>
            <td><button class="control-button" data-command="BRT">Back Right</button></td>
        </tr>
    </table>

    <script>
        $(document).ready(function () {
            const time_resolution = 300; // Time resolution in milliseconds

            // Active send state
            const active = {
                intervalId: null,
                command: null,
                pointerId: null,
                keyboard: false
            };
            let idleInterval = null; // interval id for sending 'NON' when idle

            function sendCommand(command) {
                // Keep a console log for debugging
                console.log('Command sent:', command);

                // Use the existing CGI endpoint used by the project
                $.get('/control.cgi', { command: command })
                    .done(function (response) {
                        console.log('Response:', response);
                    })
                    .fail(function () {
                        console.error('Failed to send command:', command);
                    });
            }

            function startSendingCommand(command, opts = {}) {
                // If already sending same command from same source, do nothing
                if (active.command === command && active.intervalId !== null) return;

                // Clear any previous interval
                if (active.intervalId !== null) {
                    clearInterval(active.intervalId);
                    active.intervalId = null;
                }

                // Stop idle 'NON' sending while actively sending a command
                if (idleInterval !== null) {
                    clearInterval(idleInterval);
                    idleInterval = null;
                }

                // Set active state
                active.command = command;
                active.pointerId = opts.pointerId !== undefined ? opts.pointerId : null;
                active.keyboard = !!opts.keyboard;

                // Send immediately, then at interval
                sendCommand(command);
                active.intervalId = setInterval(() => sendCommand(command), time_resolution);
            }

            function stopSendingCommand(opts = {}) {
                // If pointerId is provided, only stop if it matches the active one
                if (opts.pointerId !== undefined) {
                    if (active.pointerId === null || active.pointerId !== opts.pointerId) return;
                }

                // If keyboard stop requested but active wasn't keyboard-sourced, ignore
                if (opts.keyboard && !active.keyboard) return;


                if (active.intervalId !== null) {
                    clearInterval(active.intervalId);
                    active.intervalId = null;
                }

                // Send a single NON to tell the robot we're idle
                sendCommand('NON');

                // Restart idle repeating send if not already running
                if (idleInterval === null) {
                    idleInterval = setInterval(() => sendCommand('NON'), time_resolution);
                }

                // Reset active state
                active.command = null;
                active.pointerId = null;
                active.keyboard = false;
            }

            // Attach pointer and keyboard handlers to each control button
            document.querySelectorAll('.control-button').forEach(btn => {
                const command = btn.getAttribute('data-command');

                // Pointer events cover mouse, touch and pen
                btn.addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    try { btn.setPointerCapture(e.pointerId); } catch (err) { /* ignore */ }
                    startSendingCommand(command, { pointerId: e.pointerId, keyboard: false });
                });

                btn.addEventListener('pointerup', (e) => {
                    try { btn.releasePointerCapture(e.pointerId); } catch (err) { /* ignore */ }
                    stopSendingCommand({ pointerId: e.pointerId });
                });

                btn.addEventListener('pointercancel', (e) => {
                    stopSendingCommand({ pointerId: e.pointerId });
                });

                // Keyboard: start on keydown (Space or Enter), stop on keyup
                btn.addEventListener('keydown', (e) => {
                    if (e.repeat) return; // ignore auto-repeat keydown
                    if (e.code === 'Space' || e.code === 'Enter') {
                        e.preventDefault();
                        startSendingCommand(command, { keyboard: true });
                    }
                });

                btn.addEventListener('keyup', (e) => {
                    if (e.code === 'Space' || e.code === 'Enter') {
                        e.preventDefault();
                        stopSendingCommand({ keyboard: true });
                    }
                });
            });

            // Start idle sending immediately (send once then repeat)
            sendCommand('NON');
            idleInterval = setInterval(() => sendCommand('NON'), time_resolution);
        });
    </script>
    
    
</body>
</html>
